!/ ------------------------------------------------------------------- /
      Module W3FLD1MD
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III      NOAA/NCEP/NOPP |
!/                  |           B. G. Reichl            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         18-Mar-2015 |
!/                  +-----------------------------------+
!/
!/    01-Jul-2013 : Origination.                        ( version 4.xx )
!/    18-Mar-2015 : Clean-up/prepare for distribution   ( version 5.12 )
!/    15-Jan-2016 : Updates                             ( version 5.12 )
!/                                                      ( B. G. Reichl )
!/    27-Jul-2016 : Added Charnock output  (J.Meixner)  ( version 5.12 )
!/                  
!/
!/    Copyright 2009 National Weather Service (NWS),
!/       National Oceanic and Atmospheric Administration.  All rights
!/       reserved.  WAVEWATCH III is a trademark of the NWS. 
!/       No unauthorized use without permission.
!/
!  1. Purpose :
!
!     This Module contains routines to compute the wind stress vector
!     from the wave spectrum, the wind vector, and the lower atmospheric 
!     stability (the form included here is for neutral conditions, but
!     the structure needed to include stability is included in comments).  
!     The stress calculated via this subroutine is
!     intended for coupling to serve as the boundary condition
!     between the ocean and atmosphere, and (for now)
!     and has no impact on the wave spectrum calculated. 
!     The calculation in w3fld1 is based on the method
!     presented in Reichl, Hara, and Ginis (2014), "Sea State Dependence
!     of the Wind Stress under Hurricane Winds."
!
!  2. Variables and types :
!
!     Not applicable.
!
!  3. Subroutines and functions :
!
!      Name       Type  Scope    Description
!     ----------------------------------------------------------------
!      W3FLD1     Subr. Public   Reichl et al. 2014 stress calculation
!      INFLD1     Subr. Public   Corresponding initialization routine.
!      APPENDTAIL Subr. Public   Modification of tail for calculation
!      SIG2WN     Subr. Public   Depth-dependent dispersion relation
!      WND2Z0M    Subr. Public   Wind to roughness length
!     ----------------------------------------------------------------
!
!  4. Subroutines and functions used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      STRACE    Subr. W3SERVMD Subroutine tracing.
!     ----------------------------------------------------------------
!
!  5. Remarks :
!
!  6. Switches :
!
!     !/S  Enable subroutine tracing.
!     !/
!
!  7. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
!
      PUBLIC
      ! Tail_Choice: Chose the method to determine the level of the tail
      INTEGER, SAVE :: Tail_Choice
      REAL, SAVE    :: Tail_Level !if Tail_Choice=0, tail is constant
      REAL, SAVE    :: Tail_transition_ratio1! freq/fpi where tail 
                                             !  adjustment begins
      REAL, SAVE    :: Tail_transition_ratio2! freq/fpi where tail 
                                             !  adjustment ends
!/
      ! Hard-coded, option for form of HWRF Z0 parameterization
      !  I_FORM = 1 -> HWRF 2015
      !  I_FORM = 4 -> HWRF 2016
      INTEGER, PARAMETER :: I_FORM = 4
!/
      CONTAINS
!/ ------------------------------------------------------------------- /
      SUBROUTINE W3FLD1( ASPC, FPI, WNDX,WNDY, ZWND,               & 
                    DEPTH, RIB, UST, USTD, Z0, TAUNUX,TAUNUY, CHARN)
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III      NOAA/NCEP/NOPP |
!/                  |           B. G. Reichl            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         18-Mar-2015 |
!/                  +-----------------------------------+
!/
!/    01-Jul-2013 : Origination.                        ( version 4.xx )
!/    18-Mar-2015 : Prepare for submission              ( version 5.12 )
!/
!  1. Purpose :
!
!     Diagnostic stress vector calculation from wave spectrum, lower
!     atmosphere stability, and wind vector (at some given height).
!     The height of wind vector is assumed to be within the constant
!     stress layer.  These parameterizations are meant to be performed
!     at wind speeds > 10 m/s, and may not converge for extremely young
!     seas (i.e. starting from flat sea conditions).
!
!  2. Method :
!     See Reichl et al. (2014).
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       ASPC    Real   I   1-D Wave action spectrum.
!       FPI     Real   I   Peak input frequency. 
!       WNDX    Real   I   X-dir wind (assumed referenced to current)    
!       WNDY    Real   I   Y-dir wind (assumed referenced to current)
!       ZWND    Real   I   Wind height.
!       DEPTH   Real   I   Water depth.
!       RIB     REAL   I   Bulk Richardson in lower atmosphere
!                          (for determining stability in ABL to get
!                          10 m neutral wind)
!       TAUNUX  Real   0   X-dir viscous stress (guessed from prev.)
!       TAUNUY  Real   0   Y-dir viscous stress (guessed from prev.)
!       UST     Real   O   Friction velocity.
!       USTD    Real   O   Direction of friction velocity.
!       Z0      Real   O   Surface roughness length
!       CHARN   Real   O,optional    Charnock parameter 
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      STRACE    Subr. W3SERVMD Subroutine tracing.
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3ASIM    Subr. W3ASIMMD Air-sea interface module.
!      W3EXPO    Subr.   N/A    Point output post-processor.
!      GXEXPO    Subr.   N/A    GrADS point output post-processor.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!  8. Structure :
!
!     See source code.
!
!  9. Switches :
!
!     !/S  Enable subroutine tracing.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE CONSTANTS, ONLY: GRAV, DWAT, DAIR, TPI, PI, KAPPA
      USE W3GDATMD, ONLY: NK, NTH, NSPEC, SIG, DTH, XFR, TH
      USE W3ODATMD, ONLY: NDSE
      USE W3SERVMD, ONLY: EXTCDE
!/S      USE W3SERVMD, ONLY: STRACE
!/
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      REAL, INTENT(IN)        :: ASPC(NSPEC), WNDX, WNDY,  & 
                                 ZWND, DEPTH, RIB, FPI
      REAL, INTENT(OUT)       :: UST, USTD, Z0 
      REAL, INTENT(OUT), OPTIONAL :: CHARN
      REAL, INTENT(INOUT)     :: TAUNUX, TAUNUY
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      REAL, PARAMETER         ::  NU=0.105/10000.0 
      REAL, PARAMETER         ::  DELTA=0.03
      ! Commonly used parameters
      REAL                    ::  wnd_in_mag, wnd_in_dir
      !For Calculating Tail
      REAL                    ::  KMAX, KTAILA, KTAILB, KTAILC
      REAL                    ::  SAT, z01, z02, u10
      LOGICAL                 ::  ITERFLAG
      INTEGER                 ::  COUNT
      !For Iterations
      REAL                    ::  DTX, DTY, iter_thresh, &
                                  USTSM, Z0SM, Z1
      !For stress calculation
      REAL                    ::  WAGE, CBETA, BP, CD,       &
                                  USTRB, ANGDIF, USTAR, ZNU, & 
                                  TAUT, TAUX, TAUY, BETAG
      !For wind profile calculation
      REAL                    ::  UPROFV, VPROFV
      !For wind profile iteration
      REAL                    ::  WND_1X, WND_1Y, &
                                  WND_2X, WND_2Y, &
                                  WND_3X, WND_3Y, &
                                  DIFU10XX, DIFU10YX, DIFU10XY, DIFU10YY, &
                                  FD_A, FD_B, FD_C, FD_D, &
                                  DWNDX, DWNDY, &
                                  APAR, CH,UITV, VITV,USTL,&
                                  CK
      !For adding stability to wind profile
      REAL                    ::  WND_TOP, ANG_TOP, WND_PA, WND_PE,   &
                                  WND_PEx, WND_PEy, WND_PAx, WND_PAy, &
                                  CDM,z0t
      INTEGER                 ::  NKT, K, T, Z2, ITER, ZI, ZII, &
                                  I, CTR, ITERATION, KA1, KA2, &
                                  KA3, KB
      ! For defining extended spectrum with appended tail.
      REAL, ALLOCATABLE, DIMENSION(:)   :: WN, DWN, CP,SIG2
      REAL, ALLOCATABLE, DIMENSION(:,:) :: SPC2
      REAL, ALLOCATABLE, DIMENSION(:)   :: TLTN, TLTE, TAUD, &
                                           TLTND, &
                                           TLTED, ZOFK, UPROF, VPROF, &
                                           FTILDE, UP1, VP1, UP, VP, &
                                           TLTNA, TLTEA
!/S      INTEGER, SAVE           :: IENT = 0
      LOGICAL                 :: FSFL1,FSFL2
      LOGICAL                 :: IT_FLAG1, IT_FLAG2
      LOGICAL                 :: HEIGHTFLG
      LOGICAL, SAVE           :: FIRST = .TRUE.
!/
!/ ------------------------------------------------------------------- /
!/
!/S      CALL STRACE (IENT, 'W3FLD1')
!
! 0.  Initializations ------------------------------------------------ *
!
!     **********************************************************
!     ***    The initialization routine should include all   ***
!     *** initialization, including reading data from files. ***
!     **********************************************************
!
      IF ( FIRST ) THEN
          CALL INFLD
          FIRST  = .FALSE.
       END IF
       wnd_in_mag = sqrt( wndx**2 + wndy**2 )
       wnd_in_dir = atan2(wndy, wndx)
       !----------------------------------------------------------+
       ! Assume wind input is neutral 10 m wind.  If wind input   +
       ! is not 10 m, tail level will need to be calculated based +
       ! on esimation of 10 m wind.                               +
       !----------------------------------------------------------+
       HEIGHTFLG =.FALSE.
!/URIC!Option for if not 10m wind
!/URIC      HEIGHTFLG = (abs(zwnd-10.).gt.1.) ! True if not 10m
       IF (HEIGHTFLG) THEN
          IterFLAG=.true.
          COUNT = 1 !COUNT is now counting iteration over z0
          ustar=sqrt(0.001)*wnd_in_mag
          call ust_to_znot(ustar,z0t,z01,I_FORM)
          do while(IterFLAG)
             ustar=wnd_in_mag*kappa/log(zwnd/z01)
             !if (.not.(ustar.ge.0.0)) then
             !   print*,'fld1l237',ustar,z01,zwnd,wnd_in_mag
             !endif
             CALL ust_to_znot(ustar,z0t,z02,I_FORM)
             if ( (abs(z01/z02-1.).GT.0.00001) .AND. &
                  (COUNT.LT.20))THEN
                z01 = z02
             else
                IterFLAG = .false.
             endif
             COUNT = COUNT + 1
          enddo
          u10=ustar/kappa*log(10./z01)
       ELSE
          u10 = wnd_in_mag
       ENDIF
       ustar=0.

       ! - Get tail level
       if (Tail_Choice.eq.0) then
          SAT=Tail_Level
       elseif (Tail_Choice.eq.1) then
          CALL WND2SAT(U10,SAT)
       endif
!
! 1.  Attach Tail ---------------------------------------------------- *
!
! If the depth remains constant, the allocation could be limited to the
!   first time step.  Since this code is designed for coupled 
!   implementation where the water level can change, I keep it the 
!   allocation on every time step.  When computational efficiency is
!   important, this process may be rethought.
!
      ! i. Find maximum wavenumber of input spectrum
      call sig2wn(sig(nk),depth,kmax)
      NKT = NK
      ! ii. Find additional wavenumber bins to extended to cm scale waves
      DO WHILE ( KMAX .LT. 366.0 ) 
        NKT = NKT + 1
        KMAX = ( KMAX * XFR**2 )
      ENDDO!K<366
      ! iii. Allocate new "extended" spectrum
      ALLOCATE( WN(NKT), DWN(NKT), CP(NKT), SIG2(NKT),SPC2(NKT,NTH), &
                TLTN(NKT), TLTE(NKT), TAUD(NKT), &
                TLTND(NKT), TLTED(NKT), ZOFK(NKT), UPROF(NKT+1),&
                VPROF(NKT+1), FTILDE(NKT), UP1(NKT+1),VP1(NKT+1), &
                UP(NKT+1), VP(NKT+1), TLTNA(NKT),TLTEA(NKT))
!
! 1a. Build Discrete Wavenumbers for defining extended spectrum on---- *
!
      !i. Copy existing sig to extended sig2, calculate phase speed.
      DO K = 1, NK !existing spectrum
         call sig2wn(sig(k),depth,wn(k))
         CP(K) = ( SIG(K) / WN(K) )
         sig2(k) = sig(k)
      ENDDO!K
      !ii. Calculate extended sig2 and phase speed.
      DO K = ( NK + 1 ), ( NKT) !extension
         sig2(k) = sig2(k-1) *XFR
         call sig2wn(sig2(k),depth,wn(k))
         CP(K) = SIG2(K) / WN(K)
      ENDDO!K
      !iii. Calculate dk's for integrations.
      DO K = 1, NKT-1
        DWN(K) = WN(K+1) - WN(K)
      ENDDO
      DWN(NKT) = WN(NKT)*XFR**2 - WN(NKT)
!
! 1b. Attach initial tail--------------------------------------------- *
! 
      !i. Convert action spectrum to variance spectrum
      !   SPC(k,theta) = A(k,theta) * sig(k)
      ! This could be redone for computational efficiency
      I=0
      DO K=1, NK
        DO T=1, NTH
          I = I + 1
          SPC2(K,T) = ASPC(I)  * SIG(K)
        ENDDO!T
      ENDDO!K
      !ii. Extend k^-3 tail to extended spectrum
      DO K=NK+1, NKT
        DO T=1, NTH
          SPC2(K,T)=SPC2(NK,T)*WN(NK)**3.0/WN(K)**(3.0)
        ENDDO!T
      ENDDO!K
!
! 1c. Calculate transitions for new (constant saturation ) tail ------ *
!
!
      !i. Find wavenumber for beginning spc level transition to tail
      call sig2wn (FPI*TPI*tail_transition_ratio1,depth,ktaila )
      !ii. Find wavenumber for ending spc level transition to tail
      call sig2wn (FPI*TPI*tail_transition_ratio2,depth,ktailb )
      !iii. Find wavenumber for ending spc direction transition to tail
      KTAILC= KTAILB * 2.0
      !iv. Find corresponding indices of wavenumber transitions
      KA1 = 2     ! Do not modify 1st wavenumber bin
      DO WHILE ( ( KTAILA .GE. WN(KA1) ) .AND. (KA1 .LT. NKT-6) )
        KA1 = KA1 + 1
      ENDDO
      KA2 = KA1+2
      DO WHILE ( ( KTAILB .GE. WN(KA2) ) .AND. (KA2 .LT. NKT-4) )
        KA2 = KA2 + 1
      ENDDO
      KA3 = KA2+2
      DO WHILE ( ( KTAILC .GE. WN(KA3)) .AND. (KA3 .LT. NKT-2) )
        KA3 = KA3 + 1
      ENDDO
      !v. Call subroutine to perform actually tail truncation
      ! only if there is some energy in spectrum
      CALL APPENDTAIL(SPC2, WN, NKT, KA1, KA2, KA3,&
           wnd_in_dir, SAT)
      ! Spectrum is now set for stress integration
!
! 2.  Prepare for iterative calculation of wave-form stress----------- *
!
      DTX = 0.00005 
      DTY = 0.00005
      iter_thresh = 0.001
!
! 2a. Calculate initial guess for viscous stress from smooth-law------ *
! (Would be preferable to use prev. step)
!
      Z0SM = 0.001  !Guess
      IT_FLAG1 = .true.
      ITERATION = 0
      DO WHILE( IT_FLAG1 )
        ITERATION = ITERATION + 1
        Z1 = Z0SM
        USTSM = KAPPA * wnd_in_mag / ( LOG( ZWND / Z1 ) )
        Z0SM = 0.132 * NU / USTSM
        IF ( (ABS( Z0SM - Z1 ) .LT. 10.0**(-6)) .OR.&
             ( ITERATION .GT. 5 )) THEN
          IT_FLAG1 = .false.
        ENDIF
      ENDDO

      ITERATION = 1
      ! Guessed values of viscous stress
      TAUNUX = USTSM**2 * DAIR * wndx / wnd_in_mag
      TAUNUY = USTSM**2 * DAIR * wndy / wnd_in_mag
!
! 3.  Enter iterative calculation of wave form/skin stress----------  *
!
      IT_FLAG1 = .true.
      DO WHILE (IT_FLAG1)
        DO ITER=1, 3 !3 loops for TAUNU iteration
          Z2 = NKT
          ! First : TAUNUX + DX
          IF (ITER .EQ. 1) THEN
            TAUNUX = TAUNUX + DTX
          ! Second : TAUNUY + DY
          ELSEIF (ITER .EQ. 2) THEN
            TAUNUX = TAUNUX - DTX
            TAUNUY = TAUNUY + DTY
          ! Third : unmodified
          ELSEIF (ITER .EQ. 3) THEN
            TAUNUY = TAUNUY - DTY
          ENDIF
          ! Near surface turbulent stress = taunu
          TLTN(1) = TAUNUY
          TLTE(1) = TAUNUX
!|---------------------------------------------------------------------|
!|-----Calculate first guess at growth rate and local turbulent stress-|
!|-----for integration as a function of wavedirection------------------|
!|---------------------------------------------------------------------|
          DO ZI = 2, NKT 
            USTL=0.0
            TLTND(zi)=0.0
            TLTED(zi)=0.0
            Z2 = Z2 - 1
            ! Use value of prev. wavenumber/height
            TAUD(ZI) = ATAN2( TLTN(ZI-1), TLTE(ZI-1))
            USTL = SQRT( SQRT( TLTN(ZI-1)**2 + TLTE(ZI-1)**2 )/ DAIR )
            DO T = 1, NTH
              ANGDIF=TAUD(ZI)-TH(T) !stress/wave angle
              IF ( COS( ANGDIF ) .GE. 0.0 ) THEN !Waves aligned
                WAGE = CP(Z2) / (USTL)
                ! First, waves much slower than wind.
                IF ( WAGE .LT. 10. ) THEN
                  CBETA = 25.0
                ! Transition from waves slower than wind to faster
                ELSEIF ( ( WAGE .GE. 10.0 ) .AND. &
                          ( WAGE .LE. 25.0 ) ) THEN
                  CBETA = 10.0 + 15.0 * COS( PI * ( WAGE - 10.0 ) &
                          / 15.0 )
                ! Waves faster than wind
                ELSEIF ( WAGE .GT. 25.0 ) THEN
                  CBETA = -5.0
                ENDIF
              ! Waves opposing wind
              ELSE
                CBETA = -25.0
              ENDIF
              !Integrate turbulent stress
              TLTND(ZI) =TLTND(ZI)+( SIN( TH(T) ) * COS( ANGDIF )**2)&
                          * CBETA * SPC2(Z2,T) * &
                          SQRT( TLTE(ZI-1)**2 + TLTN(ZI-1)**2.0 ) &
                          * ( WN(Z2)**2.0 )*DTH
              TLTED(ZI) = TLTED(ZI)+(COS( TH(T) ) * COS( ANGDIF )**2)&
                          * CBETA * SPC2(Z2,T) * &
                          SQRT( TLTE(ZI-1)**2 + TLTN(ZI-1)**2.0 ) &
                          * ( WN(Z2)**2.0 )*DTH
           ENDDO
!|---------------------------------------------------------------------|
!|-----Complete the integrations---------------------------------------|
!|---------------------------------------------------------------------|
            IF (ZI .EQ. 2) THEN
              !First turbulent stress bin above taunu
              TLTNA(ZI) = TLTND(ZI) * DWN(Z2) * 0.5
              TLTEA(ZI) = TLTED(ZI) * DWN(Z2) * 0.5
            ELSE
              TLTNA(ZI)=(TLTND(ZI)+TLTND(ZI-1))*0.5*DWN(Z2)
              TLTEA(ZI)=(TLTED(ZI)+TLTED(ZI-1))*0.5*DWN(Z2)
            ENDIF
            TLTN(ZI)=TLTN(ZI-1)+TLTNA(ZI)
            TLTE(ZI)=TLTE(ZI-1)+TLTEA(ZI)
          ENDDO
          TAUY=TLTN(NKT)
          TAUX=TLTE(NKT)
          ! This is the first guess at the stress.
!|---------------------------------------------------------------------|
!|----Iterate til convergence------------------------------------------|
!|---------------------------------------------------------------------|
          USTRB=SQRT(SQRT(TAUY**2.0+TAUX**2.0)/DAIR)
          IT_FLAG2 = .TRUE.
          CTR=1
          DO WHILE ( (IT_FLAG2) .AND. ( CTR .LT. 10 ) )
           Z2=NKT+1
            DO ZI=1, NKT
              Z2=Z2-1
              USTL=0.0
              TLTED(zi)=0.0
              TLTND(zi)=0.0
              FTILDE(z2)=0.0
              TAUD(ZI) = ATAN2(TLTN(ZI),TLTE(ZI))
              USTL = SQRT(SQRT(TLTN(ZI)**2+TLTE(ZI)**2)/DAIR)
              DO T=1, NTH
                BETAG=0.0
                ANGDIF = TAUD(ZI)-TH(T)
                IF ( COS( ANGDIF ) .GE. 0.0 ) THEN
                  WAGE = CP(Z2)  / (USTL)
                 IF ( WAGE .LT. 10 ) THEN
                    CBETA = 25.0
                 ELSEIF ( ( WAGE .GE. 10.0 ) .AND. &
                          ( WAGE .LE. 25.0 ) ) THEN
                   CBETA = 10.0 + 15.0 * COS( PI * ( WAGE - 10.0 ) &
                          / 15.0 )
                 ELSEIF ( WAGE .GT. 25.0 ) THEN
                   CBETA = -5.0
                  ENDIF
                ELSE
                  CBETA = -25.0
                ENDIF
                BP = SQRT( (COS( TH(T) ) * COS( ANGDIF )**2.0)**2.0 &
                     + (SIN( TH(T) ) * COS( ANGDIF )**2.0)**2.0 )
                BETAG=BP*CBETA*SQRT(TLTE(ZI)**2.0+TLTN(ZI)**2.0) &
                           /(DWAT)*SIG2(Z2)/CP(Z2)**2
                FTILDE(Z2) = FTILDE(Z2) + BETAG * DWAT * GRAV &
                           * SPC2(Z2,T) * DTH
                TLTND(zi) =tltnd(zi)+ (SIN( TH(T) ) * COS( ANGDIF )**2.0)&
                            * CBETA * SPC2(Z2,T) * SQRT( &
                            TLTE(ZI)**2.0 + TLTN(ZI)**2.0 ) * &
                            ( WN(Z2)**2.0 )*dth
                TLTED(zi) = tlted(zi)+(COS( TH(T) ) * COS( ANGDIF )**2.0)&
                            * CBETA * SPC2(Z2,T) * SQRT( &
                            TLTE(ZI)**2.0 + TLTN(ZI)**2.0 ) * &
                            ( WN(Z2)**2.0 )*dth
              ENDDO
              IF (ZI .EQ. 1) THEN
                TLTNA(ZI)=TLTND(ZI)*DWN(Z2)*0.5
                TLTEA(ZI)=TLTED(ZI)*DWN(Z2)*0.5
              ELSE
                TLTNA(ZI)=(TLTND(ZI)+TLTND(ZI-1))*0.5*DWN(Z2)
                TLTEA(ZI)=(TLTED(ZI)+TLTED(ZI-1))*0.5*DWN(Z2)
              ENDIF
              IF (ZI.GT.1) then
                 TLTN(ZI)=TLTN(ZI-1)+TLTNA(ZI)
                 TLTE(ZI)=TLTE(ZI-1)+TLTEA(ZI)
              else
                 TLTN(ZI)=TAUNUY+TLTNA(ZI)
                 TLTE(ZI)=TAUNUX+TLTEA(ZI)
              endif
            ENDDO
            TAUY=TLTN(NKT) !by NKT full stress is entirely 
            TAUX=TLTE(NKT) !from turbulent stress
            TAUT=SQRT(TAUY**2.0+TAUX**2.0)
            USTAR=SQRT(SQRT(TAUY**2.0+TAUX**2.0)/DAIR)
            IF ((ABS(USTAR-USTRB)*100.0)/((USTAR+USTRB)*0.5) .GT. 0.1) THEN
               USTRB=USTAR
              CTR=CTR+1
            ELSE
              IT_FLAG2 = .FALSE.
            ENDIF
          ENDDO
          KB=1
          DO WHILE(((TLTN(KB)**2+TLTE(KB)**2)/(TAUX**2+TAUY**2)).LE. &
             .99)
             KB=KB+1
          ENDDO
!|---------------------------------------------------------------------|
!|----Now begin work on wind profile-----------------------------------|
!|---------------------------------------------------------------------|
          DO I=1,NKT
            ZOFK(I)=DELTA/WN(I)
          ENDDO
          ZNU=0.1 * 1.45E-5 / SQRT(SQRT(TAUNUX**2.0+TAUNUY**2.0)/DAIR)
          UPROF(1:NKT)=0.0
          VPROF(1:NKT)=0.0
          UPROFV=0.0
          VPROFV=0.0
          ZI=1
          Z2=NKT
          UP1(ZI) = ( ( ( WN(Z2)**2 / DELTA ) * FTILDE(z2) ) + &
                    ( DAIR / ( ZOFK(Z2) * KAPPA ) ) * ( SQRT( &
                    TLTN(ZI)**2 + TLTE(ZI)**2 ) / DAIR )**(3/2) ) &
                    * ( TLTE(ZI) ) / ( TLTE(ZI) * TAUX &
                    + TLTN(ZI) * TAUY )
          VP1(ZI) = ( ( ( WN(Z2)**2 / DELTA ) * FTILDE(z2) ) + &
                    ( DAIR / ( ZOFK(Z2) * KAPPA ) ) * ( SQRT ( &
                    TLTN(ZI)**2 + TLTE(ZI)**2 ) / DAIR )**(3/2) ) &
                    * ( TLTN(ZI) ) / ( TLTE(ZI) * TAUX &
                    + TLTN(ZI) * TAUY )
          UP(ZI) = UP1(ZI)
          VP(ZI) = VP1(ZI)
          UPROF(ZI) = DAIR / KAPPA * ( SQRT( TAUNUX**2.0 + TAUNUY**2.0 ) &
                      / DAIR )**(1.5) * ( TAUNUX / ( TAUX * &
                      TAUNUX + TAUY * TAUNUY ) ) * LOG( &
                      ZOFK(Z2) / ZNU )
          VPROF(ZI) = DAIR / KAPPA * ( SQRT( TAUNUX**2.0 + TAUNUY**2.0 ) &
                      / DAIR )**(1.5) * ( TAUNUY / ( TAUX * &
                      TAUNUX + TAUY * TAUNUY ) ) * LOG( &
                      ZOFK(Z2) / ZNU )
          DO ZI=2, KB
            Z2 = Z2 - 1
            UP1(ZI) = ( ( ( WN(Z2)**2.0 / DELTA ) * FTILDE(Z2) ) + &
                      ( DAIR / ( ZOFK(Z2) * KAPPA ) ) * ( SQRT( &
                      TLTN(ZI)**2.0 + TLTE(ZI)**2.0 ) / DAIR )**(1.5) ) &
                      * ( TLTE(ZI) ) / ( TLTE(ZI) * TAUX + &
                      TLTN(ZI) * TAUY )
            VP1(ZI) = ( ( ( WN(Z2)**2.0 / DELTA ) * FTILDE(Z2) ) + &
                      ( DAIR / ( ZOFK(Z2) * KAPPA ) ) * ( SQRT( &
                      TLTN(ZI)**2.0 + TLTE(ZI)**2.0 ) / DAIR )**(1.5) ) &
                      * ( TLTN(ZI) ) / ( TLTE(ZI) * TAUX + &
                      TLTN(ZI) * TAUY )
            UP(ZI) = UP1(ZI) * 0.5 + UP1(ZI-1) * 0.5
            VP(ZI) = VP1(ZI) * 0.5 + VP1(ZI-1) * 0.5
            UPROF(ZI) = UPROF(ZI-1) + UP(ZI) * ( ZOFK(Z2) - ZOFK(Z2+1) )
            VPROF(ZI) = VPROF(ZI-1) + VP(ZI) * ( ZOFK(Z2) - ZOFK(Z2+1) )
          ENDDO
!|---------------------------------------------------------------------|
!|----Iteration completion/checks--------------------------------------| 
!|---------------------------------------------------------------------|
          !ZI = ( KB + 1 )
          ! Now solving for 'ZWND' height wind 
          UPROF(KB+1) = UPROF(KB) + ( SQRT( SQRT( TAUY**2.0 + &
                      TAUX**2.0 ) / DAIR ) ) / KAPPA * TAUX &
                      / SQRT( TAUY**2.0 +TAUX**2.0 ) * LOG( ZWND &
                      / ZOFK(Z2) )
          VPROF(KB+1) = VPROF(KB) + ( SQRT( SQRT( TAUY**2.0 + &
                      TAUX**2.0 ) / DAIR ) ) / KAPPA * TAUY &
                      / SQRT( TAUY**2.0 +TAUX**2.0 ) * LOG( ZWND &
                      / ZOFK(Z2) )

          !---------------------------------------------+
          !  Adding stability effects for non 10m winds +
          !---------------------------------------------+
          IF (HEIGHTFLG) THEN 
            !Get Wind at top of wave boundary layer
             WND_TOP=SQRT(UPROF(KB)**2+VPROF(KB)**2)
            ! Get Wind Angle at top of wave boundary layer
            ANG_TOP=ATAN2(VPROF(KB),UPROF(KB))
            ! Stress and direction
            USTD = ATAN2(TAUY,TAUX)
            UST = SQRT( SQRT( TAUX**2 + TAUY**2 ) / DAIR)
            ! Calclate along (PA) and across (PE) wind components
            WND_PA=WND_TOP*COS(ANG_TOP-USTD)
            WND_PE=WND_TOP*SIN(ANG_TOP-USTD)
            ! Calculate cartesian aligned wind
            WND_PAx=WND_PA*cos(ustd)
            WND_PAy=WND_PA*sin(USTd)
            !Calculate cartesion across wind
            WND_PEx=WND_PE*cos(ustd+pi/2.)
            WND_PEy=WND_PE*sin(ustd+pi/2.)
            !----------------------------------------------------+
            ! If a non-neutral profile is used the effective z0  +
            ! should be computed.  This z0 can then be used      +
            ! with stability information to derive a Cd, which   +
            ! can be used to project the along-stress wind to    +
            ! the given height.                                  +
            ! i.e.: Assume neutral inside WBL calculate Z0       +
            !----------------------------------------------------+
            Z0=ZOFK(Z2)*EXP(-WND_PA*kappa/UST)                 
            if (.not.(Z0.ge.0.0))then
               !print*,'l605',zofk(z2),wnd_pa,ust
               !print*,'wind_in:',wnd_in_mag*cos(wnd_in_dir),wnd_in_mag*sin(wnd_in_dir)
               !print*,'taunux/taunuy:',taunux,taunuy
               call ust_to_znot(wnd_in_mag*sqrt(0.0015),z0t,z0,I_FORM)
               ustd=wnd_in_dir
            endif
            if (cos(wnd_in_dir-ustd).lt.0.0) then
               !print*,'Negative
               !alignment:',ustd,wnd_in_dir,atan2(taunuy,taunux)
               IT_FLAG1 = .FALSE.
               UST=-999
            endif
            ! Using that Z0 calculate
            CALL MFLUX(WND_IN_MAG*max(0.5,COS(WND_IN_DIR-USTD)),ZWND,Z0,RIB,CDM)
            WND_PA=UST/SQRT(CDM)   
            WND_PAx=WND_PA*cos(ustd)
            WND_PAy=WND_PA*sin(USTd)
            IF (ITER .EQ. 3) THEN
              WND_1X = WND_PAx+WND_PEx
              WND_1Y = WND_PAy+WND_PEy
            ELSEIF (ITER .EQ. 2) THEN
              WND_2X = WND_PAx+WND_PEx
              WND_2Y = WND_PAy+WND_PEy
            ELSEIF (ITER .EQ. 1) THEN
              WND_3X = WND_PAx+WND_PEx
              WND_3Y = WND_PAy+WND_PEy
            ENDIF
          ELSE ! 10m windseepd  
            IF (ITER .EQ. 3) THEN
              WND_1X = UPROF(KB+1)
              WND_1Y = VPROF(KB+1)
            ELSEIF (ITER .EQ. 2) THEN
              WND_2X = UPROF(KB+1)
              WND_2Y = VPROF(KB+1)
            ELSEIF (ITER .EQ. 1) THEN
              WND_3X = UPROF(KB+1)
              WND_3Y = VPROF(KB+1)
            ENDIF
          END IF
        ENDDO
        ITERATION = ITERATION + 1
        CALL APPENDTAIL(SPC2, WN, NKT, KA1, KA2, KA3,&
                      atan2(VPROF(KB),UPROF(KB)), SAT)
        DIFU10XX = WND_3X - WND_1X
        DIFU10YX = WND_3Y - WND_1Y
        DIFU10XY = WND_2X - WND_1X
        DIFU10YY = WND_2Y - WND_1Y
        FD_A = DIFU10XX / DTX
        FD_B = DIFU10XY / DTY
        FD_C = DIFU10YX / DTX
        FD_D = DIFU10YY / DTY
        DWNDX = - WNDX + WND_1X
        DWNDY = - WNDY + WND_1Y
        UITV = ABS( DWNDX )
        VITV = ABS( DWNDY )
        CH = SQRT( UITV**2.0 + VITV**2.0 )
        IF (CH .GT. 15.) THEN
          APAR = 0.5 / ( FD_A * FD_D - FD_B * FD_C )
        ELSE
          APAR = 1.0 / ( FD_A * FD_D - FD_B * FD_C )
        ENDIF
        CK=4.
        IF (((VITV/MAX(ABS(WNDY),CK) .GT. iter_thresh) .OR. &
             (UITV/MAX(ABS(WNDX),CK) .GT. iter_thresh)) .AND. &
             (ITERATION .LT. 2)) THEN
          TAUNUX = TAUNUX - APAR * ( FD_D * DWNDX - FD_B * DWNDY )
          TAUNUY = TAUNUY - APAR * ( -FD_C * DWNDX +FD_A * DWNDY )
        ELSEIF (((VITV/MAX(ABS(WNDY),CK) .GT. iter_thresh) .OR. &
             (UITV/MAX(ABS(WNDX),CK) .GT. iter_thresh)) .AND. &
             (ITERATION .LT. 24)) THEN
           iter_thresh = 0.001
           TAUNUX = TAUNUX - APAR * ( FD_D * DWNDX - FD_B * DWNDY )
           TAUNUY = TAUNUY - APAR * ( -FD_C * DWNDX +FD_A * DWNDY )
        ELSEIF (((VITV/MAX(ABS(WNDY),CK) .GT. iter_thresh) .OR. &
             (UITV/MAX(ABS(WNDX),CK) .GT. iter_thresh)) .AND. &
             (ITERATION .LT. 26)) THEN
           iter_thresh = 0.01
           TAUNUX = TAUNUX - APAR * ( FD_D * DWNDX - FD_B * DWNDY )
           TAUNUY = TAUNUY - APAR * ( -FD_C * DWNDX +FD_A * DWNDY )
        ELSEIF (((VITV/MAX(ABS(WNDY),CK) .GT. iter_thresh) .OR. &
             (UITV/MAX(ABS(WNDX),CK) .GT. iter_thresh)) .AND. &
             (ITERATION .LT. 30)) THEN
           iter_thresh = 0.05
           TAUNUX = TAUNUX - APAR * ( FD_D * DWNDX - FD_B * DWNDY )
           TAUNUY = TAUNUY - APAR * ( -FD_C * DWNDX +FD_A * DWNDY )
        ELSEIF (ITERATION .GE. 30) THEN
           write(*,*)'Attn: W3FLD1 not converged.'
           write(*,*)'      Wind (X/Y): ',WNDX,WNDY
           IT_FLAG1 = .FALSE.
           UST=-999
           TAUNUX=0.
           TAUNUY=0.
        ELSEIF (((VITV/MAX(ABS(WNDY),CK) .LT. iter_thresh) .AND.&
             (UITV/MAX(ABS(WNDX),CK) .LT. iter_thresh)) .AND. &
             (ITERATION .GE. 2)) THEN
           IT_FLAG1 = .FALSE.
        ENDIF
        ! if taunu iteration is unstable try to reset with new guess...
        if (.not.(cos(wnd_in_dir-atan2(taunuy,taunux)).ge.0.0)) then
           TAUNUX = USTSM**2 * DAIR * wndx / wnd_in_mag*.95
           TAUNUY = USTSM**2 * DAIR * wndy / wnd_in_mag*.95
        endif
     ENDDO
!|---------------------------------------------------------------------|
!|----Finish-----------------------------------------------------------|
!|---------------------------------------------------------------------|
      USTD = ATAN2(TAUY,TAUX)
      UST = SQRT( SQRT( TAUX**2 + TAUY**2 ) / DAIR)
      IF(.NOT.HEIGHTFLG) THEN
        ! Get Z0 from aligned wind
        WND_PA=WND_IN_MAG*COS(WND_IN_DIR-USTD)
        Z0 = ZWND/EXP(WND_PA*KAPPA/UST)
      ENDIF 
      CD = UST**2 / wnd_in_mag**2
      IF (PRESENT(CHARN)) THEN
         CHARN = 0.01/SQRT(SQRT( TAUNUX**2 + TAUNUY**2 )/(UST**2))
      ENDIF
      FSFL1=.not.((CD .LT. 0.01).AND.(CD .GT. 0.0001))
      FSFL2=.not.(cos(wnd_in_dir-ustd).GT.0.9)
      IF (FSFL1 .or. FSFL2) THEN
         !Fail safe to bulk
         write(*,*)'Attn: W3FLD1 failed, will output bulk...'
         IF (HEIGHTFLG) THEN
           ustar=wnd_in_mag*sqrt(0.0015)
           UST=0.0
           iteration=1
           do while(iteration.lt.10 .and. abs(UST-ustar).gt.0.01)
              if (iteration.gt.1) then
                ustar=ust
              endif
              CALL ust_to_znot(ustar,z0t,z0,I_FORM)
              CALL MFLUX(WND_IN_MAG,ZWND,Z0,RIB,CDM)
              UST = wnd_in_mag*sqrt(CDM)
              iteration=iteration+1
           enddo
           USTD = wnd_in_dir
         ELSE 
           CALL wnd2z0m(wnd_in_mag,z0)
           UST = wnd_in_mag*kappa/log(zwnd/z0)
           USTD = wnd_in_dir
           CD = UST**2 / wnd_in_mag**2
         END IF
      ENDIF
      DEALLOCATE(WN, DWN, CP,SIG2, SPC2, TLTN, TLTE, TAUD, &
                 TLTND, TLTED, ZOFK, UPROF, &
                 VPROF, FTILDE, UP1, VP1, UP, VP, TLTNA, TLTEA)
!/ End of W3FLD1 ----------------------------------------------------- /
!/
      RETURN
!
      END SUBROUTINE W3FLD1
!/ ------------------------------------------------------------------- /
      SUBROUTINE INFLD
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           B. G. Reichl            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         15-Jan-2016 |
!/                  +-----------------------------------+
!/
!/    15-Jan-2016 : Origination.                        ( version 5.12 )
!/
!  1. Purpose :
!
!     Initialization for w3fld1 (also used by w3fld2)
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      STRACE    Subr. W3SERVMD Subroutine tracing.
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3FLDX    Subr. W3FLDXMD Corresponding source term.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!  8. Structure :
!
!     See source code.
!
!  9. Switches :
!
!     !/S  Enable subroutine tracing.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE W3ODATMD, ONLY: NDSE
      USE W3GDATMD, ONLY: TAIL_ID, TAIL_LEV, TAIL_TRAN1, TAIL_TRAN2
      USE W3SERVMD, ONLY: EXTCDE
!/S      USE W3SERVMD, ONLY: STRACE
!/
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
!/S      INTEGER, SAVE           :: IENT = 0
!/
!/ ------------------------------------------------------------------- /
!/
!/S      CALL STRACE (IENT, 'INFLD')
!
! 1.  .... ----------------------------------------------------------- *
!
      Tail_Choice=Tail_ID
      Tail_Level=TAIL_Lev
      Tail_transition_ratio1 = TAIL_TRAN1
      Tail_transition_ratio2 = TAIL_TRAN2
      
!
      RETURN
!
! Formats
!

!/
!/ End of INFLD1 ----------------------------------------------------- /
!/
      END SUBROUTINE INFLD
!/
!/ ------------------------------------------------------------------- /
      SUBROUTINE APPENDTAIL(INSPC, WN2, NKT, KA1, KA2, KA3, WNDDIR,SAT)
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           B. G. Reichl            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         15-Jan-2016 |
!/                  +-----------------------------------+
!/
!/    15-Jan-2016 : Origination.                        ( version 5.12 )
!/
!  1. Purpose :
!
!     Set tail for stress calculation.
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      STRACE    Subr. W3SERVMD Subroutine tracing.
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3FLD1    Subr. W3FLD1MD Corresponding source term.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!  8. Structure :
!
!     See source code.
!
!  9. Switches :
!
!     !/S  Enable subroutine tracing.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE CONSTANTS, ONLY: TPI, PI
      USE W3GDATMD, ONLY: NTH, TH, DTH
      USE W3ODATMD, ONLY: NDSE
      USE W3SERVMD, ONLY: EXTCDE
!/S      USE W3SERVMD, ONLY: STRACE
!/
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      INTEGER, INTENT(IN) :: NKT, KA1, KA2, KA3
      REAL, INTENT(IN)    :: WN2(NKT), WNDDIR,SAT
      REAL, INTENT(INOUT)   :: INSPC(NKT,NTH)
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
!/S      INTEGER, SAVE           :: IENT = 0
      REAL                :: BT(NKT), IC, ANGLE2, ANG(NKT),&
                             NORMSPC(NTH), AVG, ANGDIF, M, MAXANG, &
                             MAXAN, MINAN
      INTEGER             :: MAI, I, K, T
      REAL, ALLOCATABLE, DIMENSION(:)  :: ANGLE1
!/
!/ ------------------------------------------------------------------- /
!/
!/S      CALL STRACE (IENT, 'APPENDTAIL')
!
! 1.  .... ----------------------------------------------------------- *
!
      !|###############################################################|
      !|##1. Get the level of the saturation spectrum in transition
      !|##   region A
      !|###############################################################|
      !-------------------------------------------
      ! 1a, get saturation level at KA1 (1.25xFPI)
      !-------------------------------------------
      BT(KA1) = 0
      ANG = 0.0
      DO T=1, NTH
        BT(KA1)=BT(KA1)+INSPC(KA1,T)*WN2(KA1)**3.0*DTH
      ENDDO
      !-----------------------------------------------
      ! 1b, Set saturation level at KA2 (3xFPI) to SAT
      !-----------------------------------------------
      BT(KA2) = SAT
      !-------------------------------------------------------------
      ! 1c, Find slope of saturation spectrum in transition region A
      !-------------------------------------------------------------
      M = ( BT(KA2) - BT(KA1) ) / ( WN2(KA2) - WN2(KA1) )
      !----------------------------------------------------------------
      ! 1d, Find intercept of saturation spectrum in transition region
      !     A
      !----------------------------------------------------------------
      IC = BT(KA1) - M * WN2(KA1)
      !------------------------------------------------------
      ! 1e, Calculate saturation level for all wavenumbers in
      !     transition region A
      !------------------------------------------------------
      DO K=KA1,KA2
        BT(K)=M*WN2(K)+IC
      ENDDO
      !|###############################################################|
      !|##2. Determine the directionality at each wavenumber in
      !|##   transition region B
      !|###############################################################|
      !-----------------------------------------------
      ! 2a, Find angle of spectral peak at KA2 (3xFPI)
      !-----------------------------------------------
      MAXANG = 0.0
      DO T=1, NTH
        IF (INSPC(KA2,T) .GT. MAXANG) THEN
          MAXANG=INSPC(KA2,T)
        ENDIF
      ENDDO
      !-------------------------------
      ! 2b, Check if peak spans 2 bins
      !-------------------------------
      !MAI = total number of angles of peak (if it spans more than 1)
      MAI = 0
      DO T=1, NTH
        IF (MAXANG .EQ. INSPC(KA2,T)) THEN
          MAI = MAI+1
        ENDIF
      ENDDO
      !ANGLE1 = angles that correspond to peak (array)
      MAI = MAX(1,MAI)
      ALLOCATE(ANGLE1(MAI))
      !-----------------------------------------------------
      ! 2c, If peak spans 2 or more bins it must be averaged
      !-----------------------------------------------------
      K=1
      DO T=1, NTH
        IF (MAXANG .EQ. INSPC(KA2,T)) THEN
          ANGLE1(K) = TH(T)
          K=K+1
        ENDIF
      ENDDO
      DO K=1, MAI
        DO WHILE (ANGLE1(K) .LT. 0.0)
          ANGLE1(K) = ANGLE1(K) + TPI
        ENDDO
        DO WHILE (ANGLE1(K) .GE. TPI)
          ANGLE1(K) = ANGLE1(K) - TPI
        ENDDO
      ENDDO
      IF (MAI .GT. 1) THEN
        MAXAN = ANGLE1(1)
        MINAN = ANGLE1(1)
        DO I=2, MAI
          IF (MAXAN .LT. ANGLE1(I) )THEN
            MAXAN = ANGLE1(I)
          ENDIF
          IF (MINAN .GT. ANGLE1(I) )THEN
            MINAN = ANGLE1(I)
          ENDIF
        ENDDO
      !------------------------------------------------------
      !  Need to distinguish if mean cross the origin (0/2pi)
      !------------------------------------------------------
        IF (MAXAN-MINAN .GT. PI) THEN
          DO I=1, MAI
            IF (MAXAN - ANGLE1(I) .GT. PI) THEN
              ANGLE1(I) = ANGLE1(I) + TPI
            ENDIF
          ENDDO
          ANGLE2=SUM(ANGLE1)/MAX(REAL(MAI),1.)
        ELSE
           ANGLE2=SUM(ANGLE1)/MAX(REAL(MAI),1.)
        ENDIF
      ELSE
        ANGLE2=ANGLE1(1)
      ENDIF
      DO WHILE (ANGLE2 .LT. 0.0)
        ANGLE2 = ANGLE2 + TPI
      ENDDO
      DO WHILE (ANGLE2 .GE. TPI)
        ANGLE2 = ANGLE2 - TPI
      ENDDO
      !
      !---------------------------------------------------
      ! This deals with angles that are less than 90
      !---------------------------------------------------
      if (cos(angle2-wnddir) .ge. 0.) then  !Less than 90
        m=asin(sin(wnddir-angle2))/(wn2(ka3)-wn2(ka2))
        ic=angle2
        do k=ka2, ka3
          ang(k)=ic +m*(wn2(k)-wn2(ka2))
        enddo
      else
      !----------------------------------------------------
      !  This deals with angels that turn clockwise
      !----------------------------------------------------
        if (sin(wnddir-angle2).GE.0) then
         m=acos(cos(wnddir-angle2))/(wn2(ka3)-wn2(ka2))
          ic=angle2
          do k=ka2, ka3
            ang(k)=ic+m*(wn2(k)-wn2(ka2))
          enddo
        else
      !-----------------------------------------------------
      !  This deals with angels that cross counter-clockwise
      !-----------------------------------------------------
          m=acos(cos(wnddir-angle2))/(wn2(ka3)-wn2(ka2))
          ic=angle2
          do k=ka2, ka3
            ang(k)=ic-m*(wn2(k)-wn2(ka2))
          enddo
        endif
      endif
      !----------------------------------------------
      ! Region A, Saturation level decreased linearly
      ! while direction is maintained
      !----------------------------------------------
      DO K=KA1, KA2-1
         AVG=SUM(INSPC(K,:))/MAX(REAL(NTH),1.)
         DO T=1,NTH
            INSPC(K,T)=BT(K)*INSPC(K,T)/TPI/(WN2(K)**3.0)/AVG
         ENDDO
      ENDDO
      !-----------------------------------------------------------
      ! Region B, Saturation level left flat while spectrum turned
      ! to direction of wind
      !-----------------------------------------------------------
      DO K = KA2, KA3
        DO T=1, NTH
          angdif=th(t)-ang(k)
          IF (COS(ANGDIF) .GT. 0.0) THEN
            NORMSPC(T) = COS(ANGDIF)**2.0
          ELSE
            NORMSPC(T)=0.0
          ENDIF
       ENDDO
        AVG=SUM(NORMSPC)/MAX(REAL(NTH),1.)
        DO T=1, NTH
          INSPC(K,T) = SAT * NORMSPC(T)/TPI/(WN2(K)**3.0)/AVG
        ENDDO
      ENDDO
      DO T=1, NTH
        angdif=th(t)-wnddir
        IF (COS(ANGDIF) .GT. 0.0) THEN
          NORMSPC(T) = COS(ANGDIF)**2.0
        ELSE
          NORMSPC(T) = 0.0
        ENDIF
      ENDDO
      AVG=SUM(NORMSPC)/MAX(REAL(NTH),1.)!1./4.
      DO K=KA3+1, NKT
        DO T=1, NTH
         INSPC(K,T)=NORMSPC(T)*(SAT)/TPI/(WN2(K)**3.0)/AVG
        ENDDO
      ENDDO
      DEALLOCATE(ANGLE1)
!
! Formats
!
!/
!/ End of APPENDTAIL ----------------------------------------------------- /
!/
      RETURN
!
      END SUBROUTINE APPENDTAIL
!/ ------------------------------------------------------------------- /
!/
!/ ------------------------------------------------------------------- /
      SUBROUTINE SIG2WN(SIG,DEPTH,WN)
!/ ------------------------------------------------------------------- /
!Author: Brandon Reichl (GSO/URI)
!Origination  : 2013
!Update       : March - 18 - 2015
!Puropse      : Convert from angular frequency to wavenumber
!               using full gravity wave dispersion relation
!               if tanh(kh)<0.99, otherwise uses deep-water
!               approximation.
!NOTE: May be a better version internal to WW3 that can replace this.
!/ ------------------------------------------------------------------- /
!/
        use constants, only: GRAV
!/
        implicit none
!/
        REAL,INTENT(IN)    :: SIG,DEPTH
        REAL,INTENT(OUT)   :: WN
!/
        real    :: wn1,wn2,sig1,sig2,dsigdk
        integer :: i
        logical :: SWITCH
!/ ------------------------------------------------------------------- /
        wn1=sig**2/GRAV
        wn2=wn1+0.00001
        SWITCH=.true.
!/ ------------------------------------------------------------------- /
        if (tanh(wn1*depth).LT.0.99) then
           do i=1,5
              if (SWITCH) then
                 sig1=sqrt(GRAV*wn1*tanh(wn1*depth))
                 sig2=sqrt(GRAV*wn2*tanh(wn2*depth))
                 if (sig1.lt.sig*.99999.or.sig1.gt.sig*1.00001) then
                    dsigdk=(sig2-sig1)/(wn2-wn1)
                    WN1=WN1+(SIG2-SIG1)/dsigdk
                    wn2=wn1+wn1*0.00001
                 else 
                    SWITCH = .FALSE.
                 endif
              endif
           enddo
        endif
!/
        WN=WN1
!/
        RETURN
      END SUBROUTINE SIG2WN
!/ ------------------------------------------------------------------- /
!/
      SUBROUTINE ust_to_znot(ust,znott,ZNOTM,Form)
      !----------------------------------------------------------------+
      ! Prog    : ust_to_znot
      ! Author  : Brandon Reichl (URI/GSO)
      ! Date    : Dec 16, 2015
      ! Purpose : Calculate bulk z0 and thermal roughness based on ustar
      !         : using look-up table
      !  Form = 1 for HWRF 2015 ()
      !  Form = 4 for HWRF 2016 ()
      !----------------------------------------------------------------+
      IMPLICIT NONE
      ! -- Input --
      ! ust - surface (atmospheric side) friction velocity [m/s]
      REAL, INTENT(IN) :: UST
      INTEGER, INTENT(IN) :: FORM
      ! -- Output --
      ! znott - thermal roughness length [m]
      REAL, INTENT(OUT) :: ZNOTT,ZNOTM
      ! -- Program variables
      real, parameter,dimension(161) :: USTAR &
         =(/0.00000000,0.02500000,0.05000000, &
            0.07500000,0.10000000,0.12500000, &
            0.15000000,0.17500000,0.20000000, &
            0.22500000,0.25000000,0.27500000, &
            0.30000000,0.32500000,0.35000000, &
            0.37500000,0.40000000,0.42500000, &
            0.45000000,0.47500000,0.50000000, &
            0.52500000,0.55000000,0.57500000, &
            0.60000000,0.62500000,0.65000000, &
            0.67500000,0.70000000,0.72500000, &
            0.75000000,0.77500000,0.80000000, &
            0.82500000,0.85000000,0.87500000, &
            0.90000000,0.92500000,0.95000000, &
            0.97500000,1.00000000,1.02500000, &
            1.05000000,1.07500000,1.10000000, &
            1.12500000,1.15000000,1.17500000, &
            1.20000000,1.22500000,1.25000000, &
            1.27500000,1.30000000,1.32500000, &
            1.35000000,1.37500000,1.40000000, &
            1.42500000,1.45000000,1.47500000, &
            1.50000000,1.52500000,1.55000000, &
            1.57500000,1.60000000,1.62500000, &
            1.65000000,1.67500000,1.70000000, &
            1.72500000,1.75000000,1.77500000, &
            1.80000000,1.82500000,1.85000000, &
            1.87500000,1.90000000,1.92500000, &
            1.95000000,1.97500000,2.00000000, &
            2.02500000,2.05000000,2.07500000, &
            2.10000000,2.12500000,2.15000000, &
            2.17500000,2.20000000,2.22500000, &
            2.25000000,2.27500000,2.30000000, &
            2.32500000,2.35000000,2.37500000, &
            2.40000000,2.42500000,2.45000000, &
            2.47500000,2.50000000,2.52500000, &
            2.55000000,2.57500000,2.60000000, &
            2.62500000,2.65000000,2.67500000, &
            2.70000000,2.72500000,2.75000000, &
            2.77500000,2.80000000,2.82500000, &
            2.85000000,2.87500000,2.90000000, &
            2.92500000,2.95000000,2.97500000, &
            3.00000000,3.02500000,3.05000000, &
            3.07500000,3.10000000,3.12500000, &
            3.15000000,3.17500000,3.20000000, &
            3.22500000,3.25000000,3.27500000, &
            3.30000000,3.32500000,3.35000000, &
            3.37500000,3.40000000,3.42500000, &
            3.45000000,3.47500000,3.50000000, &
            3.52500000,3.55000000,3.57500000, &
            3.60000000,3.62500000,3.65000000, &
            3.67500000,3.70000000,3.72500000, &
            3.75000000,3.77500000,3.80000000, &
            3.82500000,3.85000000,3.87500000, &
            3.90000000,3.92500000,3.95000000, &
            3.97500000,4.00000000/)

      real, parameter,dimension(161) :: Z01  &
         =(/0.00000100,0.00000129,0.00000463, &
            0.00000988,0.00001701,0.00002606, &
            0.00003706,0.00005329,0.00007134, &
            0.00009192,0.00011319,0.00013633, &
            0.00016095,0.00018692,0.00021424, &
            0.00025929,0.00029435,0.00033334, &
            0.00037707,0.00042560,0.00047699, &
            0.00053425,0.00059597,0.00066202, &
            0.00073224,0.00080646,0.00088449, &
            0.00096613,0.00105117,0.00113937, &
            0.00123050,0.00132432,0.00142058, &
            0.00151901,0.00161935,0.00172135, &
            0.00182472,0.00192920,0.00203451, &
            0.00214038,0.00224652,0.00235268, &
            0.00245856,0.00256389,0.00266840, &
            0.00277182,0.00287386,0.00297723, &
            0.00307512,0.00317089,0.00326430, &
            0.00335507,0.00344295,0.00352591, &
            0.00360837,0.00368516,0.00376119, &
            0.00383105,0.00389623,0.00395651, &
            0.00401167,0.00406149,0.00410577, &
            0.00414431,0.00417689,0.00420330, &
            0.00422366,0.00423665,0.00424307, &
            0.00424226,0.00423389,0.00421817, &
            0.00419436,0.00416239,0.00412198, &
            0.00407288,0.00401480,0.00394982, &
            0.00387431,0.00378953,0.00369537, &
            0.00359177,0.00348165,0.00336045, &
            0.00323054,0.00309251,0.00294729, &
            0.00279905,0.00264438,0.00248811, &
            0.00233331,0.00218356,0.00204043, &
            0.00191196,0.00179761,0.00169672, &
            0.00161241,0.00154069,0.00147850, &
            0.00142516,0.00137627,0.00135039, &
            0.00133815,0.00132852,0.00132085, &
            0.00131486,0.00131031,0.00130692, &
            0.00130466,0.00130320,0.00130239, &
            0.00130212,0.00130225,0.00130266, &
            0.00130327,0.00130397,0.00130468, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482/)
      real, parameter,dimension(161) :: Z0t1   &
         =(/0.00000100,0.00000129,0.00000463, &
            0.00000988,0.00001701,0.00002606, &
            0.00003706,0.00004950,0.00006369, &
            0.00008063,0.00007374,0.00006546, &
            0.00005794,0.00005127,0.00004548, &
            0.00004100,0.00003696,0.00003404, &
            0.00003213,0.00003008,0.00002755, &
            0.00002520,0.00002308,0.00002121, &
            0.00001958,0.00001821,0.00001710, &
            0.00001624,0.00001563,0.00001526, &
            0.00001510,0.00001516,0.00001542, &
            0.00001585,0.00001644,0.00001718, &
            0.00001804,0.00001902,0.00002008, &
            0.00002123,0.00002243,0.00002368, &
            0.00002497,0.00002628,0.00002760, &
            0.00002892,0.00003025,0.00003161, &
            0.00003292,0.00003424,0.00003556, &
            0.00003691,0.00003830,0.00003972, &
            0.00004129,0.00004294,0.00004475, &
            0.00004577,0.00004772,0.00005060, &
            0.00005434,0.00005888,0.00006412, &
            0.00006998,0.00007636,0.00008320, &
            0.00009062,0.00009812,0.00010622, &
            0.00011485,0.00012415,0.00013408, &
            0.00014531,0.00015812,0.00017307, &
            0.00019088,0.00021245,0.00023793, &
            0.00026995,0.00030954,0.00035861, &
            0.00041943,0.00049270,0.00058463, &
            0.00069764,0.00083605,0.00100475, &
            0.00120503,0.00144951,0.00174088, &
            0.00208404,0.00248229,0.00294393, &
            0.00345121,0.00400802,0.00461957, &
            0.00525883,0.00593786,0.00666998, &
            0.00743728,0.00826872,0.00905020, &
            0.00979045,0.01051245,0.01123916, &
            0.01197584,0.01272949,0.01352234, &
            0.01432094,0.01516815,0.01607433, &
            0.01705029,0.01810706,0.01925560, &
            0.02050661,0.02187020,0.02335566, &
            0.02497118,0.02672355,0.02861789, &
            0.03065737,0.03284287,0.03517270, &
            0.03764230,0.04024389,0.04296619, &
            0.04579403,0.04870807,0.05168443, &
            0.05469433,0.05770379,0.06067318, &
            0.06355696,0.06630319,0.06885327, &
            0.07114146,0.07309454,0.07463139, &
            0.07566259,0.07609005,0.07609579, &
            0.07609579,0.07609579,0.07609579, &
            0.07609579,0.07609579,0.07609579, &
            0.07609579,0.07609579,0.07609579, &
            0.07609579,0.07609579,0.07609579, &
            0.07609579,0.07609579,0.07609579, &
            0.07609579,0.07609579,0.07609579, &
            0.07609579,0.07609579/)

      real, parameter,dimension(161) :: Z02  &
         =(/0.00000100,0.00000129,0.00000463, &
            0.00000988,0.00001701,0.00002606, &
            0.00003706,0.00005006,0.00006527, &
            0.00008226,0.00010157,0.00012234, &
            0.00014566,0.00017116,0.00019887, &
            0.00022884,0.00026217,0.00029708, &
            0.00033438,0.00037637,0.00041712, &
            0.00045786,0.00049857,0.00053922, &
            0.00057980,0.00062030,0.00066070, &
            0.00070100,0.00074121,0.00078131, &
            0.00082132,0.00086122,0.00090101, &
            0.00094070,0.00098030,0.00101979, &
            0.00105918,0.00109847,0.00113766, &
            0.00117675,0.00121575,0.00125466, &
            0.00129348,0.00133220,0.00137084, &
            0.00140940,0.00144787,0.00148625, &
            0.00152456,0.00156278,0.00160093, &
            0.00160906,0.00163479,0.00165878, &
            0.00168314,0.00170711,0.00173070, &
            0.00175388,0.00177666,0.00179904, &
            0.00182100,0.00184254,0.00186365, &
            0.00188434,0.00190459,0.00192440, &
            0.00194377,0.00196270,0.00198118, &
            0.00199921,0.00201679,0.00203391, &
            0.00205057,0.00206677,0.00208251, &
            0.00209779,0.00211261,0.00212696, &
            0.00214085,0.00215427,0.00216723, &
            0.00217973,0.00219176,0.00220333, &
            0.00221445,0.00222511,0.00223556, &
            0.00224527,0.00225454,0.00226337, &
            0.00227176,0.00227972,0.00228725, &
            0.00229436,0.00230105,0.00230732, &
            0.00231319,0.00231866,0.00232374, &
            0.00232843,0.00233275,0.00233670, &
            0.00234029,0.00234354,0.00234645, &
            0.00234903,0.00235125,0.00235324, &
            0.00235493,0.00235635,0.00235749, &
            0.00235839,0.00235906,0.00235951, &
            0.00235976,0.00235984,0.00235975, &
            0.00235953,0.00235918,0.00235873, &
            0.00235820,0.00235761,0.00235699, &
            0.00235635,0.00235584,0.00235584, &
            0.00235584,0.00235584,0.00235584, &
            0.00235584,0.00235584,0.00235584, &
            0.00235584,0.00235584,0.00235584, &
            0.00235584,0.00235584,0.00235584, &
            0.00235584,0.00235584,0.00235584, &
            0.00235584,0.00235584,0.00235584, &
            0.00235584,0.00235584,0.00235584, &
            0.00235584,0.00235584,0.00235584, &
            0.00235584,0.00235584,0.00235584, &
            0.00235584,0.00235584,0.00235584, &
            0.00235584,0.00235584,0.00235584, &
            0.00235584,0.00235584/)
      real, parameter,dimension(161) :: Z0t2   &
         =(/0.00000100,0.00000129,0.00000463, &
            0.00000988,0.00001701,0.00002606, &
            0.00003706,0.00005006,0.00006527, &
            0.00008226,0.00006449,0.00005226, &
            0.00004334,0.00003691,0.00003225, &
            0.00002882,0.00002620,0.00002428, &
            0.00002283,0.00002171,0.00002082, &
            0.00002010,0.00001951,0.00001901, &
            0.00001859,0.00001823,0.00001791, &
            0.00001762,0.00001735,0.00001711, &
            0.00001688,0.00001666,0.00001645, &
            0.00001625,0.00001606,0.00001587, &
            0.00001568,0.00001551,0.00001533, &
            0.00001516,0.00001499,0.00001482, &
            0.00001466,0.00001449,0.00001433, &
            0.00001418,0.00001402,0.00001387, &
            0.00001372,0.00001357,0.00001342, &
            0.00001326,0.00001311,0.00001296, &
            0.00001282,0.00001267,0.00001253, &
            0.00001239,0.00001225,0.00001211, &
            0.00001197,0.00001184,0.00001171, &
            0.00001157,0.00001144,0.00001132, &
            0.00001119,0.00001106,0.00001094, &
            0.00001081,0.00001069,0.00001057, &
            0.00001045,0.00001033,0.00001022, &
            0.00001010,0.00000999,0.00000987, &
            0.00000976,0.00000965,0.00000954, &
            0.00000943,0.00000933,0.00000922, &
            0.00000911,0.00000901,0.00000891, &
            0.00000880,0.00000870,0.00000860, &
            0.00000851,0.00000841,0.00000831, &
            0.00000822,0.00000812,0.00000803, &
            0.00000793,0.00000784,0.00000775, &
            0.00000766,0.00000757,0.00000748, &
            0.00000740,0.00000731,0.00000723, &
            0.00000714,0.00000706,0.00000698, &
            0.00000689,0.00000681,0.00000673, &
            0.00000665,0.00000657,0.00000649, &
            0.00000642,0.00000634,0.00000626, &
            0.00000619,0.00000612,0.00000604, &
            0.00000597,0.00000590,0.00000583, &
            0.00000576,0.00000569,0.00000563, &
            0.00000556,0.00000549,0.00000543, &
            0.00000536,0.00000530,0.00000524, &
            0.00000518,0.00000511,0.00000505, &
            0.00000499,0.00000494,0.00000488, &
            0.00000482,0.00000476,0.00000471, &
            0.00000465,0.00000459,0.00000454, &
            0.00000449,0.00000443,0.00000438, &
            0.00000433,0.00000428,0.00000427, &
            0.00000427,0.00000427,0.00000427, &
            0.00000427,0.00000427,0.00000427, &
            0.00000427,0.00000427,0.00000427, &
            0.00000427,0.00000427/)

      real, parameter,dimension(161) :: Z03  &
         =(/0.00000100,0.00000129,0.00000463, &
            0.00000988,0.00001701,0.00002606, &
            0.00003706,0.00005329,0.00007134, &
            0.00009192,0.00011319,0.00013633, &
            0.00016095,0.00018692,0.00021424, &
            0.00025929,0.00029435,0.00033334, &
            0.00037707,0.00042560,0.00047699, &
            0.00053425,0.00059597,0.00066202, &
            0.00073224,0.00080646,0.00088449, &
            0.00096613,0.00105117,0.00113937, &
            0.00123050,0.00132432,0.00142058, &
            0.00151901,0.00161935,0.00172135, &
            0.00182472,0.00192920,0.00203451, &
            0.00214038,0.00224652,0.00235268, &
            0.00245856,0.00256389,0.00266840, &
            0.00277182,0.00287386,0.00297723, &
            0.00307512,0.00317089,0.00326430, &
            0.00335507,0.00344295,0.00352591, &
            0.00360837,0.00368516,0.00376119, &
            0.00383105,0.00389623,0.00395651, &
            0.00401167,0.00406149,0.00410577, &
            0.00414431,0.00417689,0.00420330, &
            0.00422366,0.00423665,0.00424307, &
            0.00424226,0.00423389,0.00421817, &
            0.00419436,0.00416239,0.00412198, &
            0.00407288,0.00401480,0.00394982, &
            0.00387431,0.00378953,0.00369537, &
            0.00359177,0.00348165,0.00336045, &
            0.00323054,0.00309251,0.00294729, &
            0.00279905,0.00264438,0.00248811, &
            0.00233331,0.00218356,0.00204043, &
            0.00191196,0.00179761,0.00169672, &
            0.00161241,0.00154069,0.00147850, &
            0.00142516,0.00137627,0.00135039, &
            0.00133815,0.00132852,0.00132085, &
            0.00131486,0.00131031,0.00130692, &
            0.00130466,0.00130320,0.00130239, &
            0.00130212,0.00130225,0.00130266, &
            0.00130327,0.00130397,0.00130468, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482,0.00130482, &
            0.00130482,0.00130482/)
      real, parameter,dimension(161) :: Z0t3   &
         =(/0.00000100,0.00000129,0.00000463, &
            0.00000988,0.00001701,0.00002606, &
            0.00003706,0.00004950,0.00006369, &
            0.00008063,0.00005816,0.00004667, &
            0.00003838,0.00003218,0.00002753, &
            0.00002442,0.00002199,0.00002042, &
            0.00001932,0.00001834,0.00001724, &
            0.00001589,0.00001447,0.00001352, &
            0.00001279,0.00001196,0.00001119, &
            0.00001049,0.00000984,0.00000924, &
            0.00000869,0.00000819,0.00000772, &
            0.00000729,0.00000690,0.00000654, &
            0.00000621,0.00000590,0.00000563, &
            0.00000537,0.00000514,0.00000492, &
            0.00000473,0.00000455,0.00000438, &
            0.00000424,0.00000410,0.00000397, &
            0.00000386,0.00000376,0.00000366, &
            0.00000358,0.00000350,0.00000343, &
            0.00000336,0.00000330,0.00000325, &
            0.00000320,0.00000315,0.00000311, &
            0.00000307,0.00000304,0.00000301, &
            0.00000299,0.00000297,0.00000295, &
            0.00000294,0.00000294,0.00000294, &
            0.00000295,0.00000296,0.00000298, &
            0.00000302,0.00000306,0.00000311, &
            0.00000318,0.00000327,0.00000337, &
            0.00000350,0.00000365,0.00000383, &
            0.00000404,0.00000428,0.00000456, &
            0.00000490,0.00000528,0.00000573, &
            0.00000624,0.00000682,0.00000748, &
            0.00000822,0.00000902,0.00000990, &
            0.00001079,0.00001170,0.00001261, &
            0.00001347,0.00001428,0.00001504, &
            0.00001570,0.00001629,0.00001644, &
            0.00001647,0.00001645,0.00001639, &
            0.00001630,0.00001619,0.00001605, &
            0.00001590,0.00001574,0.00001556, &
            0.00001538,0.00001519,0.00001500, &
            0.00001480,0.00001461,0.00001442, &
            0.00001423,0.00001405,0.00001387, &
            0.00001370,0.00001353,0.00001338, &
            0.00001323,0.00001308,0.00001294, &
            0.00001281,0.00001268,0.00001255, &
            0.00001242,0.00001230,0.00001217, &
            0.00001204,0.00001190,0.00001176, &
            0.00001160,0.00001144,0.00001126, &
            0.00001107,0.00001086,0.00001083, &
            0.00001083,0.00001083,0.00001083, &
            0.00001083,0.00001083,0.00001083, &
            0.00001083,0.00001083,0.00001083, &
            0.00001083,0.00001083,0.00001083, &
            0.00001083,0.00001083,0.00001083, &
            0.00001083,0.00001083,0.00001083, &
            0.00001083,0.00001083/)
      real, parameter,dimension(161) :: Z04    &
         =(/0.00000000,0.00000120,0.00000434, &
            0.00000929,0.00001605,0.00002465, &
            0.00003511,0.00005065,0.00006804, &
            0.00008752,0.00010839,0.00013004, &
            0.00015363,0.00017853,0.00021990, &
            0.00024803,0.00028075,0.00031964, &
            0.00036195,0.00040891,0.00046049, &
            0.00051408,0.00057384,0.00063779, &
            0.00070579,0.00077767,0.00085331, &
            0.00093250,0.00101498,0.00110055, &
            0.00118897,0.00127999,0.00137337, &
            0.00146885,0.00156385,0.00163508, &
            0.00170498,0.00177315,0.00183919, &
            0.00190071,0.00196221,0.00202060, &
            0.00207559,0.00212853,0.00217534, &
            0.00221607,0.00225617,0.00229024, &
            0.00231942,0.00234350,0.00236228, &
            0.00237534,0.00238323,0.00238472, &
            0.00238018,0.00236922,0.00235155, &
            0.00232790,0.00229690,0.00225877, &
            0.00221328,0.00216018,0.00210142, &
            0.00203355,0.00195765,0.00187346, &
            0.00178385,0.00168369,0.00157466, &
            0.00146051,0.00133501,0.00120299, &
            0.00105872,0.00095834,0.00090722, &
            0.00085311,0.00079668,0.00073896, &
            0.00068121,0.00062503,0.00057213, &
            0.00052410,0.00048206,0.00044594, &
            0.00041668,0.00039218,0.00037232, &
            0.00035509,0.00034177,0.00033744, &
            0.00033413,0.00033157,0.00032966, &
            0.00032827,0.00032731,0.00032672, &
            0.00032639,0.00032628,0.00032632, &
            0.00032647,0.00032668,0.00032691, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706,0.00032706, &
            0.00032706,0.00032706/)
      real, parameter,dimension(161) :: Z0t4  &
         =(/0.00000000,0.00000061,0.00000234, &
            0.00000518,0.00000915,0.00001431, &
            0.00002069,0.00002800,0.00003656, &
            0.00004671,0.00003230,0.00002580, &
            0.00002103,0.00001749,0.00001501, &
            0.00001313,0.00001182,0.00001093, &
            0.00001032,0.00000976,0.00000911, &
            0.00000836,0.00000758,0.00000711, &
            0.00000667,0.00000622,0.00000580, &
            0.00000542,0.00000507,0.00000474, &
            0.00000445,0.00000418,0.00000393, &
            0.00000370,0.00000351,0.00000342, &
            0.00000335,0.00000328,0.00000323, &
            0.00000318,0.00000314,0.00000311, &
            0.00000309,0.00000308,0.00000308, &
            0.00000308,0.00000310,0.00000313, &
            0.00000316,0.00000320,0.00000326, &
            0.00000332,0.00000339,0.00000348, &
            0.00000357,0.00000368,0.00000380, &
            0.00000393,0.00000409,0.00000426, &
            0.00000446,0.00000469,0.00000494, &
            0.00000525,0.00000561,0.00000604, &
            0.00000655,0.00000719,0.00000800, &
            0.00000901,0.00001037,0.00001216, &
            0.00001472,0.00001700,0.00001835, &
            0.00001995,0.00002181,0.00002395, &
            0.00002639,0.00002911,0.00003208, &
            0.00003521,0.00003841,0.00004161, &
            0.00004459,0.00004741,0.00004989, &
            0.00005205,0.00005331,0.00005343, &
            0.00005339,0.00005320,0.00005289, &
            0.00005248,0.00005199,0.00005146, &
            0.00005087,0.00005025,0.00004961, &
            0.00004895,0.00004829,0.00004763, &
            0.00004698,0.00004635,0.00004573, &
            0.00004514,0.00004458,0.00004404, &
            0.00004353,0.00004304,0.00004258, &
            0.00004212,0.00004168,0.00004125, &
            0.00004081,0.00004036,0.00003989, &
            0.00003940,0.00003887,0.00003829, &
            0.00003766,0.00003696,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646,0.00003646, &
            0.00003646,0.00003646/)
      INTEGER :: i_dn, i_up
      REAL :: DUST=0.025

      if (.not.(UST.GE.0.0)) then
         print*,'UST negative in ust_to_znot:',UST
         !stop
      endif

      if (UST.lt.4.0) THEN
         i_dn=floor(UST/DUST)+1
         i_up=i_dn+1
         if (form.eq.1) then
            ZnotT=z0t1(i_dn)+(UST-USTAR(i_dn)) * &
                 (Z0t1(i_up)-Z0t1(i_dn))/DUST
            ZnotM=z01(i_dn)+(UST-USTAR(i_dn)) *  &
                 (Z01(i_up)-Z01(i_dn))/DUST
         elseif (form.eq.2) then
            ZnotT=z0t2(i_dn)+(UST-USTAR(i_dn)) * &
                 (Z0t2(i_up)-Z0t2(i_dn))/DUST
            ZnotM=z02(i_dn)+(UST-USTAR(i_dn)) *  &
                  (Z02(i_up)-Z02(i_dn))/DUST
         elseif (form.eq.3) then
            ZnotT=z0t3(i_dn)+(UST-USTAR(i_dn)) * &
                 (Z0t3(i_up)-Z0t3(i_dn))/DUST
            ZnotM=z03(i_dn)+(UST-USTAR(i_dn)) *  &
                  (Z03(i_up)-Z03(i_dn))/DUST
         elseif (form.eq.4) then
            ZnotT=z0t4(i_dn)+(UST-USTAR(i_dn)) * &
                 (Z0t4(i_up)-Z0t4(i_dn))/DUST
            ZnotM=z04(i_dn)+(UST-USTAR(i_dn)) *  &
                  (Z04(i_up)-Z04(i_dn))/DUST
         endif
      else
         if (form.eq.1) then
            ZNOTT=z0t1(161)
            ZNOTM=z01(161)
         elseif (form.eq.2) then
            ZNOTT=z0t2(161)
            ZNOTM=z02(161)
         elseif (form.eq.3) then
            ZNOTT=z0t3(161)
            ZNOTM=z03(161)
         elseif (form.eq.4) then
            ZNOTT=z0t4(161)
            ZNOTM=z04(161)
         endif
      endif

      return
    END SUBROUTINE ust_to_znot
!/ ------------------------------------------------------------------- /
    SUBROUTINE MFLUX(WND,ZH,Z0,RIB,CD)
!/
!/ DATE: 03/17/2015
!/ Imported by: Brandon Reichl (GSO)
!/ Purpose:
!/   Calculate stability dependent fluxes
!/   Needed when coupled to atmosphere.
!/ Inputs:
!/   WND - Wind speed (m/s)
!/   ZH  - Atm. height of WND (m)
!/   Z0  - Surface roughness length (m)
!/   RIB - Lower atm. bulk Richardson (non-dimensional)
!/ Outputs:
!/   CD  - Drag coefficient for ZH (Tau/(rho_a U_ZH^2))
!/ ------------------------------------------------------------------- /
!/

      USE CONSTANTS, only: GRAV, TPI, KAPPA
!}
      IMPLICIT NONE
      REAL, INTENT(IN) :: WND,ZH,Z0,RIB
      REAL, INTENT(OUT):: CD
      real, parameter :: c=0.76
      real, parameter :: a=5.0
      REAL :: ZETA2, zetat, zeta0,ZETA,z0b
      REAL :: FS,FMZ, FM0, FHZ, FH0,FM,FH
      REAL :: ZETAo, ZETA2o, DZD, DZ,ZT,DT,CDN
      INTEGER :: I, IT
!/
      ! Use Rb to calculate zeta
      ZETA=kappa*Rib/0.03
      !Estimate stability functions
      ZETA0=ZETA/ZH*Z0
      CD=(kappa/log(ZH/Z0))**2 !Guess z0t
      !if (.not.(WND*sqrt(CD).ge.0.0)) then
      !   print*,'USTAR not pos :',WND
      !   print*,'Cd            :',sqrt(CD)
      !   print*,'RIB           :',RIB
      !   print*,'zwnd          :',zh
      !   print*,'z0            :',z0
      !endif
      call ust_to_znot(WND*sqrt(CD),ZT,z0b, I_FORM)
      ZETAT=ZETA/ZH*ZT/100.
      ZETAo=1.0e+10
      ZETA2o=0.0e+00
      IT=1
      IF (ABS(ZETA).LT.0.001) THEN
         IT=0
         FMZ = 1./kappa * log(ZH)
         FM0 = 1./kappa * log(Z0)
         FHZ = FMZ
         FH0 = 1./kappa * log(Z0)
         FM=FMZ-FM0
         FH=FHZ-FH0
      ENDIF
      DO I=1,30
         ZETA0=ZETA/ZH*Z0
         ZETAT=ZETA/ZH*Z0
         IF (IT.EQ.1) THEN
            IF (ZETA.GT.10.) THEN
               FMZ = 1./kappa*(c*ZETA+17.193+0.5*a-10.0*c)
               FHZ = FMZ
            ELSEIF((ZETA.GT..5).AND.(ZETA.LE.10.)) THEN
               FMZ = 1./kappa*(8.*log(zeta)+4.25*ZETA**(-1) &
                    - 0.5*ZETA**(-2) + a*.5- 1.648 )
               FHZ = FMZ
            ELSEIF((ZETA.GT.0).AND.(ZETA.LE..5))THEN
               FMZ = 1./kappa*( log(zeta) + a*zeta)
               FHZ = FMZ
            ELSEIF(ZETA.LT.0)THEN
               FMZ = 1./kappa* (log(zh)-log(((1.-16.*zeta)**(1./2.)+1.)&
                    *((1-16*zeta)**(1./4.)+1.)**2)+2.*atan((1.-16.*zeta)**(1./4.)))
               FM0 =1./kappa* (log(abs(z0))-log(((1.-16.*zeta0)**(1./2.)+1.)&
                    *((1-16*zeta0)**(1./4.)+1.)**2)+2.*atan((1.-16.*zeta0)**(1./4.)))
               FHZ = 1./kappa*(log(abs(zh))-2.*log(1.+(1.-16.*zeta)**(1./2.)) )
               FH0 = 1./kappa*(log(abs(zetat))-2.*log(1.+(1.-16.*zetat)**(1./2.)) )
               FS = (1.-16.*zeta0)**(-1./2.)
            ENDIF
            IF (ZETA0.GT.10.) THEN
               FM0 = 1./kappa*(c*ZETA0+17.193+0.5*a-10.0*c)
               FH0 = 1./kappa*(c*ZETAT+17.193+0.5*a-10.0*c)
               FS = c*ZETA0
            ELSEIF((ZETA0.GT..5).AND.(ZETA0.LE.10.)) THEN
               FM0 = 1./kappa*(8.*log(zeta0)+4.25*ZETA0**(-1) &
                    - 0.5*ZETA0**(-2) + a*.5- 1.648 )
               FH0 = 1./kappa*(8.*log(zetaT)+4.25*ZETAT**(-1.) &
                    - 0.5*ZETAT**(-2.) +a*.5 - 1.648 )
               FS = 8. - 4.25* zeta0**(-1.) +.5*zeta0**(-2)
            ELSEIF((ZETA0.GT.0).AND.(ZETA0.LE..5))THEN
               FM0 = 1./kappa*( log(zeta0) + a*zeta0)
               FH0 =1./kappa*( log(zetat) + a*zetat)
               FS = 1. + a*zeta0
            ENDIF
            FM=FMz-FM0
            FH=FHZ-FH0
            ZETA2=kappa*Rib*FM**2/(FH+2/kappa*FS)
            DZ=(ZETA-ZETA2)/ZETA
            if (.NOT.((abs(DZ).LT.1.0e-4).AND.(I.LT.30))) then
               DZD=(ZETA2-ZETA2o)/(ZETA-ZETAo)
               ZETAo=ZETA
               ZETA=(ZETA2-ZETAo*DZD)/(1.-DZD)
               ZETA2o=ZETA2
            elseif (abs(DZ).LE.1.0e-3) THEN
               it=0
            elseif (abs(DZ).GT.1.0e-3.AND.(I.EQ.30)) THEN
               ! If MFLUX fails use neutral value.
               !print*,'MFLUX FAIL, use neutral '
               !print*,'Wind: ',WND,'RIB: ',rib
               FMZ = 1./kappa * log(ZH)
               FM0 = 1./kappa * log(Z0)
               FHZ = FMZ
               FH0 = 1./kappa * log(Z0)
               FM=FMZ-FM0
               FH=FHZ-FH0
            endif
         endif
         CD=1/FM**2
      ENDDO
      FMZ = 1./kappa * log(ZH)
      FM0 = 1./kappa * log(Z0)
      FM=FMZ-FM0
      CDN=1/FM**2
      IF (abs(CD/CDN-1.).gt.0.5) THEN
         CD=CDN
      ENDIF
      RETURN
      END SUBROUTINE MFLUX
!/ ------------------------------------------------------------------- /
      SUBROUTINE WND2Z0M( W10M , ZNOTM )
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           B. G. Reichl            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         04-Aug-2016 |
!/                  +-----------------------------------+
!/
!/    09-Apr-2014 : Last Update.                        ( version 5.12 )
!/    15-Aug-2016 : Updated for 2016 HWRF z0            ( J. Meixner   )
!/
!  1. Purpose :
!
!     Get bulk momentum z0 from 10-m wind.
!          Bulk stress corresponds to 2015 GFDL Hurricane model
!          Not published yet, but contact Brandon Reichl or
!          Isaac Ginis (Univ. of Rhode Island) for further info 
!
!  2. Method :
!          This has now been updated for 2016 HWRF z0 using routines 
!          from HWRF  znot_m_v1, Biju Thomas, 02/07/2014
!           and       znot_wind10m Weiguo Wang, 02/24/2016
!
!  3. Parameters :
!       Name  Unit  Type      Description 
!     ----------------------------------------------------------------
!       W10M   m/s  input    10 m neutral wind [m/s]
!       ZNOTM  m    output   Roughness scale for momentum
!     ----------------------------------------------------------------
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      STRACE    Subr. W3SERVMD Subroutine tracing.
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3FLD1    Subr. W3FLD1MD Corresponding source term.
!      W3FLD2    Subr. W3FLD2MD Corresponding source term. 
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!  8. Structure :
!
!     See source code.
!
!  9. Switches :
!
!     !/S  Enable subroutine tracing.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/S      USE W3SERVMD, ONLY: STRACE
!/
      IMPLICIT NONE
      REAL, INTENT(IN) :: W10M
      REAL, INTENT(OUT):: ZNOTM

      !Parameters from znot_m_v1
      REAL, PARAMETER :: bs0 = -8.367276172397277e-12
      REAL, PARAMETER :: bs1 = 1.7398510865876079e-09
      REAL, PARAMETER :: bs2 = -1.331896578363359e-07
      REAL, PARAMETER :: bs3 = 4.507055294438727e-06
      REAL, PARAMETER :: bs4 = -6.508676881906914e-05
      REAL, PARAMETER :: bs5 = 0.00044745137674732834
      REAL, PARAMETER :: bs6 = -0.0010745704660847233

      REAL, PARAMETER :: cf0 = 2.1151080765239772e-13
      REAL, PARAMETER :: cf1 = -3.2260663894433345e-11
      REAL, PARAMETER :: cf2 = -3.329705958751961e-10
      REAL, PARAMETER :: cf3 = 1.7648562021709124e-07
      REAL, PARAMETER :: cf4 = 7.107636825694182e-06
      REAL, PARAMETER :: cf5 = -0.0013914681964973246
      REAL, PARAMETER :: cf6 = 0.0406766967657759

      !Variables from znot_m_v6
      REAL, PARAMETER :: p13 = -1.296521881682694e-02
      REAL, PARAMETER :: p12 =  2.855780863283819e-01
      REAL, PARAMETER :: p11 = -1.597898515251717e+00
      REAL, PARAMETER :: p10 = -8.396975715683501e+00

      REAL, PARAMETER :: p25 =  3.790846746036765e-10
      REAL, PARAMETER :: p24 =  3.281964357650687e-09
      REAL, PARAMETER :: p23 =  1.962282433562894e-07
      REAL, PARAMETER :: p22 = -1.240239171056262e-06
      REAL, PARAMETER :: p21 =  1.739759082358234e-07
      REAL, PARAMETER :: p20 =  2.147264020369413e-05

      REAL, PARAMETER :: p35 =  1.840430200185075e-07
      REAL, PARAMETER :: p34 = -2.793849676757154e-05
      REAL, PARAMETER :: p33 =  1.735308193700643e-03
      REAL, PARAMETER :: p32 = -6.139315534216305e-02
      REAL, PARAMETER :: p31 =  1.255457892775006e+00
      REAL, PARAMETER :: p30 = -1.663993561652530e+01

      REAL, PARAMETER :: p40 =  4.579369142033410e-04

      !Variables from znot_wind10m
      REAL            :: Z10, U10,AAA,TMP

      !setversion 
      INTEGER, PARAMETER ::  IVAR=217
!/S      INTEGER, SAVE           :: IENT = 0
!/S      CALL STRACE (IENT, 'WND2Z0M')


      !Values as set in znot_wind10m
      Z10=10.0
      U10=W10M
      if (U10 > 85.0) U10=85.0
      if (U10 < 1.0)  U10 =1.0


      IF (IVAR.EQ.216) THEN
        !HWRF 2016 
        !Calculation of z0 as in znot_m_v1
        IF ( U10 .LE. 5.0 ) THEN
          ZNOTM = (0.0185 / 9.8*(7.59e-4*U10**2+2.46e-2*U10)**2)
        ELSEIF (U10 .GT. 5.0 .AND. U10 .LT. 10.0) THEN
          ZNOTM =.00000235*(U10**2 - 25 ) + 3.805129199617346e-05
        ELSEIF ( U10 .GE. 10.0  .AND. U10 .LT. 60.0) THEN
          ZNOTM = bs6 + bs5*U10 + bs4*U10**2 + bs3*U10**3 + bs2*U10**4 +&
                bs1*U10**5 + bs0*U10**6
        ELSE
          ZNOTM = cf6 + cf5*U10 + cf4*U10**2 + cf3*U10**3 + cf2*U10**4 +&
                cf1*U10**5 + cf0*U10**6
        END IF

        !Modifications as in znot_wind10m for icoef_sf=4 

        !for wind<20, cd similar to icoef=2 at 10m, then reduced 
        TMP=0.4*0.4/(ALOG(10.0/ZNOTM))**2   ! cd at zlev
        AAA=0.75
        IF (U10 < 20) THEN
          AAA=0.99
        ELSEIF(U10 < 45.0) THEN
          AAA=0.99+(U10-20)*(0.75-0.99)/(45.0-20.0)
        END IF
        ZNOTM=Z10/EXP( SQRT(0.4*0.4/(TMP*AAA)) )
      ELSEIF (IVAR.EQ.217) THEN
        !HWRF 2017 --icoef_sf .EQ. 6
        if (U10 >= 0.0 .and.  U10 <= 6.5 ) then
          ZNOTM = exp( p10 + p11*U10 + p12*U10**2 + p13*U10**3)
        elseif (U10 > 6.5 .and. U10 <= 15.7) then
          ZNOTM = p25*U10**5 + p24*U10**4 + p23*U10**3 + p22*U10**2+p21*U10 + p20
        elseif (U10 > 15.7 .and. U10 <= 53.0) then
          ZNOTM = exp( p35*U10**5 + p34*U10**4 + p33*U10**3 +p32*U10**2+ p31*U10 + p30 )
        elseif ( U10 > 53.0) then
          ZNOTM = p40
        else
          write(*,*) 'Wrong input U10 value:',U10
        endif

      ENDIF !IVAR

      END SUBROUTINE WND2Z0M
!/ ------------------------------------------------------------------- /
      SUBROUTINE WND2SAT(WND10,SAT)
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           B. G. Reichl            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         04-Aug-2016 |
!/                  +-----------------------------------+
!/
!/    15-Jan-2016 : Origination.                        ( version 5.12 )
!/    04-Aug-2016 : Updated for 2016 HWRF CD/U10 curve  ( J. Meixner   )
!/
!  1. Purpose :
!
!     Gives level of saturation spectrum to produce 
!         equivalent Cd as in wnd2z0m (for neutral 10m wind)
!         tuned for method of Reichl et al. 2014
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
      !Input: WND10 - 10 m neutral wind [m/s]
      !Output: SAT  - Level 1-d saturation spectrum in tail [non-dim]
!     ----------------------------------------------------------------
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      STRACE    Subr. W3SERVMD Subroutine tracing.
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3FLD1    Subr. W3FLD1MD Corresponding source term.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!  8. Structure :
!
!     See source code.
!
!  9. Switches :
!
!     !/S  Enable subroutine tracing.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!/S      USE W3SERVMD, ONLY: STRACE
!/
        IMPLICIT NONE
!/
        REAL, INTENT(IN) :: WND10
        REAL, INTENT(OUT) :: SAT
        INTEGER,PARAMETER :: IVAR=217  !Version of HWRF 
!/S      INTEGER, SAVE           :: IENT = 0
!
!/S      CALL STRACE (IENT, 'WND2SAT')
!/ Old HWRF 2015 and ST2 
!        SAT =0.000000000001237 * WND10**6 +&
!             -0.000000000364155 * WND10**5 +&
!             0.000000037435015 * WND10**4 +&
!             -0.000001424719473 * WND10**3 +&
!             0.000000471570975 * WND10**2 +&
!             0.000778467452178 * WND10**1 +&
!             0.002962335390055
!
        IF (IVAR.EQ.217) THEN
           !SAT values based on HWRF 2017 CD curve, created with 
           !fetch limited cases with ST4 physics   
          SAT=-0.000000000521597*WND10**5 &
              +0.000000077217839*WND10**4 &
              -0.000003700484247*WND10**3 &
              +0.000044478770155*WND10**2 &
              +0.000747322452084*WND10    &
              -0.001641775448375
          SAT = min(max(SAT,0.002),0.015)

      ELSEIF (IVAR.EQ.216) THEN


!     SAT values based on 
!     HWRF 2016 CD curve, created with  fetch limited cases ST4 physics
        IF (WND10<20.0) THEN
          SAT = -0.000018541921682*WND10**2  &
                +0.000751515452434*WND10     &
                +0.002466529381004
        ELSEIF (WND10<45) THEN
          SAT = -0.000000009060349*WND10**4  &
                +0.000001276678367*WND10**3  &
                -0.000068274393789*WND10**2  &
                +0.001418180888868*WND10     &
                +0.000262277682984
        ELSE
          SAT = -0.000155976275073*WND10     &
                +0.012027763023184
        ENDIF

        SAT = min(max(SAT,0.002),0.014)
      END IF !IVAR
      END SUBROUTINE WND2SAT
!
!/ End of module W3FLD1MD -------------------------------------------- /
!/
      END MODULE W3FLD1MD
